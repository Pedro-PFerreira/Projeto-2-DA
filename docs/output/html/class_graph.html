<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_PROJ_2122: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DA_PROJ_2122<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Unidade Curricular DA Projeto 2 Grupo 32</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a284b99bdb07994225dee3c2cdb59c80a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a284b99bdb07994225dee3c2cdb59c80a">Graph</a> (int <a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a>)</td></tr>
<tr class="separator:a284b99bdb07994225dee3c2cdb59c80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa693622bc2e7b16dac46139f394c475c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa693622bc2e7b16dac46139f394c475c">addEdge</a> (int src, int dest, int capacity, int flow, bool is_reversed, int dur)</td></tr>
<tr class="separator:aa693622bc2e7b16dac46139f394c475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c99c7f9e8ae631be618ce42695f8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac3c99c7f9e8ae631be618ce42695f8de">addRevEdge</a> (int src, int dest, int capacity, int flow, bool is_reversed, int duration)</td></tr>
<tr class="separator:ac3c99c7f9e8ae631be618ce42695f8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169f9beefa8bc766c7cccc8f73cbeb8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a169f9beefa8bc766c7cccc8f73cbeb8a">addReverseEdges</a> ()</td></tr>
<tr class="separator:a169f9beefa8bc766c7cccc8f73cbeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8616931ac14be4314178d892d4973cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad8616931ac14be4314178d892d4973cb">getMaxFlow</a> (vector&lt; int &gt; path)</td></tr>
<tr class="separator:ad8616931ac14be4314178d892d4973cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b0fd5632022b15231c6e755d7f8039"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a89b0fd5632022b15231c6e755d7f8039">getNodes</a> ()</td></tr>
<tr class="separator:a89b0fd5632022b15231c6e755d7f8039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe53f5d640fd633e100aa77c6e714f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abe53f5d640fd633e100aa77c6e714f41">getSize</a> () const</td></tr>
<tr class="separator:abe53f5d640fd633e100aa77c6e714f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c53b71d188d57779ab60d0b4f2fad45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5c53b71d188d57779ab60d0b4f2fad45">bfs</a> (int v)</td></tr>
<tr class="separator:a5c53b71d188d57779ab60d0b4f2fad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7332849f074a9e23ececfe3acd16152d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7332849f074a9e23ececfe3acd16152d">bfs_path1_2</a> (int a, int b)</td></tr>
<tr class="separator:a7332849f074a9e23ececfe3acd16152d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe6024d88acab6b95ed86dda580220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a54fe6024d88acab6b95ed86dda580220">maximumCapacityPath</a> (int s, int t)</td></tr>
<tr class="separator:a54fe6024d88acab6b95ed86dda580220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d1868c0f437ed00b2f4bea7ed3fd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a91d1868c0f437ed00b2f4bea7ed3fd6c">maximumCapacityPath1_2</a> (int s, int t)</td></tr>
<tr class="separator:a91d1868c0f437ed00b2f4bea7ed3fd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba499a6fb861d16c2e613861d9b5b08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3ba499a6fb861d16c2e613861d9b5b08">edmondsKarp</a> ()</td></tr>
<tr class="separator:a3ba499a6fb861d16c2e613861d9b5b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7737373b20b03b875ce5a620ac905e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7737373b20b03b875ce5a620ac905e8e">edmondsKarp2</a> (int size)</td></tr>
<tr class="separator:a7737373b20b03b875ce5a620ac905e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266cefab1a0b84cdf1e5a83e79227086"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a266cefab1a0b84cdf1e5a83e79227086">bfs_path</a> (int a, int b)</td></tr>
<tr class="separator:a266cefab1a0b84cdf1e5a83e79227086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde4d319dd88ea3aa15ab32c265835ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adde4d319dd88ea3aa15ab32c265835ad">criticalPath</a> ()</td></tr>
<tr class="separator:adde4d319dd88ea3aa15ab32c265835ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4521f2c38338cc37196bbb4cec422d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a4521f2c38338cc37196bbb4cec422d4b">maxTimeWait</a> (int duration)</td></tr>
<tr class="separator:a4521f2c38338cc37196bbb4cec422d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a69ea713cb2032c9841322b65e8bb548f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a69ea713cb2032c9841322b65e8bb548f">printPath</a> (vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:a69ea713cb2032c9841322b65e8bb548f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a81a76a428e630453ef019a15b9092967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a81a76a428e630453ef019a15b9092967">n</a></td></tr>
<tr class="separator:a81a76a428e630453ef019a15b9092967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a71b5e16eb9e0670fea3ecee3526abb41">nodes</a></td></tr>
<tr class="separator:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a284b99bdb07994225dee3c2cdb59c80a" name="a284b99bdb07994225dee3c2cdb59c80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284b99bdb07994225dee3c2cdb59c80a">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor of a graph. it will initializes the number of locals, and its group of nodes as well. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Number of the nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa693622bc2e7b16dac46139f394c475c" name="aa693622bc2e7b16dac46139f394c475c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa693622bc2e7b16dac46139f394c475c">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method will add an edge (or journey) to the graph, so that we can traverse it later while looking for a path. Initially, this edge is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Initial node. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination node of the edge. </td></tr>
    <tr><td class="paramname">capacity</td><td>Capacity of the vehicle on that journey. </td></tr>
    <tr><td class="paramname">flow</td><td>Number of people that is being carried in that moment. </td></tr>
    <tr><td class="paramname">is_reversed</td><td>Checks is it was already reversed or not (true if so, false otherwise). </td></tr>
    <tr><td class="paramname">dur</td><td>Duration associated to the journey. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c99c7f9e8ae631be618ce42695f8de" name="ac3c99c7f9e8ae631be618ce42695f8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c99c7f9e8ae631be618ce42695f8de">&#9670;&nbsp;</a></span>addRevEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addRevEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method adds a reversed edge to the graph. Initially, this edge is not available; however, it can be while a path is being constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Initial node. </td></tr>
    <tr><td class="paramname">dest</td><td>Destination node of the edge. </td></tr>
    <tr><td class="paramname">capacity</td><td>Capacity of the vehicle on that journey. </td></tr>
    <tr><td class="paramname">flow</td><td>Number of people that is being carried in that moment. </td></tr>
    <tr><td class="paramname">is_reversed</td><td>Checks is it was already reversed or not (true if so, false otherwise). </td></tr>
    <tr><td class="paramname">duration</td><td>Duration associated to the journey. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169f9beefa8bc766c7cccc8f73cbeb8a" name="a169f9beefa8bc766c7cccc8f73cbeb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169f9beefa8bc766c7cccc8f73cbeb8a">&#9670;&nbsp;</a></span>addReverseEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addReverseEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method will create the corresponding reversed edges, by invoking addRevEdge method for each existing edge that hasn't been reversed yet. </p>

</div>
</div>
<a id="a5c53b71d188d57779ab60d0b4f2fad45" name="a5c53b71d188d57779ab60d0b4f2fad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c53b71d188d57779ab60d0b4f2fad45">&#9670;&nbsp;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::bfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is the BFS algorithm. It traverses all the graph by its levels while there is available edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>First node to begin the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the last node is visited, otherwise it returns false. </dd></dl>

</div>
</div>
<a id="a266cefab1a0b84cdf1e5a83e79227086" name="a266cefab1a0b84cdf1e5a83e79227086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266cefab1a0b84cdf1e5a83e79227086">&#9670;&nbsp;</a></span>bfs_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::bfs_path </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method will use the BFS algorithm in order to find a path that goes from node a to node b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Initial path node. </td></tr>
    <tr><td class="paramname">b</td><td>Final path node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path found. </dd></dl>

</div>
</div>
<a id="a7332849f074a9e23ececfe3acd16152d" name="a7332849f074a9e23ececfe3acd16152d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7332849f074a9e23ececfe3acd16152d">&#9670;&nbsp;</a></span>bfs_path1_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::bfs_path1_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method uses the BFS algorithm and stores the path found. Then it calculates its size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>initial node of the path. </td></tr>
    <tr><td class="paramname">b</td><td>final path node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the path size, that is, number of locals that a path contains. </dd></dl>

</div>
</div>
<a id="adde4d319dd88ea3aa15ab32c265835ad" name="adde4d319dd88ea3aa15ab32c265835ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde4d319dd88ea3aa15ab32c265835ad">&#9670;&nbsp;</a></span>criticalPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::criticalPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method calculates the minimum time that a group will get back together in destiny. This is associated to the Critical Path Problem. </p>

</div>
</div>
<a id="a3ba499a6fb861d16c2e613861d9b5b08" name="a3ba499a6fb861d16c2e613861d9b5b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba499a6fb861d16c2e613861d9b5b08">&#9670;&nbsp;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method will use the Edmonds-Karp algorithm, in order to displays the maximum flow allowed by the graph. It will use the BFS algorithm in order to find the paths available and it will augment all the edges in each iteration. Consequently, it will make some edges unavailable, since they can no longer support more flow. Finally, it displays on the console the value of the maximum flow. </p>

</div>
</div>
<a id="a7737373b20b03b875ce5a620ac905e8e" name="a7737373b20b03b875ce5a620ac905e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7737373b20b03b875ce5a620ac905e8e">&#9670;&nbsp;</a></span>edmondsKarp2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::edmondsKarp2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method is similar to edmondsKarp; however, in case the path found does not support the input flow, it will search for a path that does so. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the group (its dimension). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The path's maximum flow value </dd></dl>

</div>
</div>
<a id="ad8616931ac14be4314178d892d4973cb" name="ad8616931ac14be4314178d892d4973cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8616931ac14be4314178d892d4973cb">&#9670;&nbsp;</a></span>getMaxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getMaxFlow </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method returns the Maximum flow allowed in a path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path discovered by the BFS algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum flow value. </dd></dl>

</div>
</div>
<a id="a89b0fd5632022b15231c6e755d7f8039" name="a89b0fd5632022b15231c6e755d7f8039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b0fd5632022b15231c6e755d7f8039">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt; Graph::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The group of existent locals (nodes). </dd></dl>

</div>
</div>
<a id="abe53f5d640fd633e100aa77c6e714f41" name="abe53f5d640fd633e100aa77c6e714f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe53f5d640fd633e100aa77c6e714f41">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method returns the graph's size. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_graph.html">Graph</a>'s size, that is, number of nodes. </dd></dl>

</div>
</div>
<a id="a54fe6024d88acab6b95ed86dda580220" name="a54fe6024d88acab6b95ed86dda580220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fe6024d88acab6b95ed86dda580220">&#9670;&nbsp;</a></span>maximumCapacityPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maximumCapacityPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method displays the path that contains the maximum capacity on the console. This value is conditioned to the value of the edge with the lowest capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Initial path node. </td></tr>
    <tr><td class="paramname">t</td><td>Final path node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91d1868c0f437ed00b2f4bea7ed3fd6c" name="a91d1868c0f437ed00b2f4bea7ed3fd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d1868c0f437ed00b2f4bea7ed3fd6c">&#9670;&nbsp;</a></span>maximumCapacityPath1_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maximumCapacityPath1_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method is similar to the maximumCapacityPath, but instead of using the maximum capacity path, it will use the intermediate ones. It will also displays the maximum transhipment needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Initial path node. </td></tr>
    <tr><td class="paramname">t</td><td>Final path node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4521f2c38338cc37196bbb4cec422d4b" name="a4521f2c38338cc37196bbb4cec422d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4521f2c38338cc37196bbb4cec422d4b">&#9670;&nbsp;</a></span>maxTimeWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::maxTimeWait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method calculates the maximum time that the elements wait, supposing that they start at the same time in the same place. It also displays the locals of where those elements wait that time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Maximum wait duration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69ea713cb2032c9841322b65e8bb548f" name="a69ea713cb2032c9841322b65e8bb548f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ea713cb2032c9841322b65e8bb548f">&#9670;&nbsp;</a></span>printPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printPath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method displays tha path found on the console. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to be displayed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a81a76a428e630453ef019a15b9092967" name="a81a76a428e630453ef019a15b9092967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a76a428e630453ef019a15b9092967">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Number of nodes (locals). </p>

</div>
</div>
<a id="a71b5e16eb9e0670fea3ecee3526abb41" name="a71b5e16eb9e0670fea3ecee3526abb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b5e16eb9e0670fea3ecee3526abb41">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_graph_1_1_node.html">Node</a>&gt; Graph::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="class_graph.html">Graph</a>'s group of nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/ppmpf/CLionProjects/DA-2Projeto/src/main/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/ppmpf/CLionProjects/DA-2Projeto/src/main/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
